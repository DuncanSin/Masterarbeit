
\section{Optimierung des ARM}
In diesem Kapitel werden die Optimierungen am Code beschrieben, der rein auf dem ARM Cortex-A8 ausgeführt wird. Hierfür werden die in \textbf{Kapitel \ref{subsec:a8}} beschriebenen Hardwareemelemte ausgenutzt.\\
In \textbf{Abschnitt \ref{subsec:armtime}} wird daher als erstes die Laufzeitmessung des gesamten Programms (Extraktion, Prozessierung und Klassifikation) erläutert, um einen Einstiegspunkt für die Optimierung zu extrahieren. In den darauffolgenden Abschnitten werden daraufhin die durchgeführten Optimierungen beschrieben. 

\subsection{Laufzeitmessung des Gesamtprogramms}\label{subsec:armtime}
Für die erste Laufzeitmessung des gesammten Programms (Extraktion, Prozessierung und Klassifikation) wurde dieses mit den in \textbf{Kapitel \ref{ph:neoncomp}} beschriebenen Compileroptionen zur automatischen Generierung von NEON-Code kompiliert. Die dabei resultierten Laufzeiten sind in \textbf{Abbildung \ref{fig:mclneon}} abzulesen.
%
\begin{figure}[htp]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/mclneon.pdf}
	\caption{Laufzeiten in ms des Musikklassifikators}
	\label{fig:mclneon}
\end{figure} 
%
Wie man aus der Abbildung entnehmen kann, fällt der größte Anteil an der Gesamtlaufzeit in allen vier Messungen (\textit{MCL1 - MCL4}) auf die Extraktionsphase. Hierbei stellt sich jetzt allerdings die Frage, ob das nur an der Komibation aus ARM und NEON liegt oder ob dieses eine generelle Tendenz ist. Darum muss die Laufzeitmessung der genannten Komibation noch mit den Laufzeitmessungen von einer reinen ARM-Implementation und der Kombination aus ARM und VFP-Einheit (vgl. \textbf{Kapitel \ref{ph:vfp}}) verglichen werden. Die Ergebnisse dieser sind in \textbf{Abbildung \ref{fig:armtime}} abzulesen. Diese und alle weiteren Messungen werden am Beispiel des in \textbf{Kapitel \ref{subsec:fset2}} beschriebenen FeatureSets durchgeführt, die Diagramme für die anderen drei FeatureSets sind für den interessierten Leser im Anhang zu finden, aber für diese sind die beschriebenen Tatsachen equivalent.
%
\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/fset2AVN.pdf}
	\caption{Laufzeiten in ms des Musikklassifikators für ARM, ARM+VFP und ARM+NEON am Beispiel des FeatureSets 2}
	\label{fig:armtime}
\end{figure} 
%
Aus \textbf{Abbildung \ref{fig:armtime}} lassen sich drei wesentliche Schlüsse ziehen:

\begin{enumerate}
\item Die Extraktionsphase hat in allen drei Fällen den größten Anteil an der Laufzeit
\item Die reine ARM-Implementation hat die schlechteste Laufzeit
\item ARM+VFP und ARM+NEON scheinen gleichwertig zu sein
\end{enumerate}

Die Punkte 1 und 2 kann man so stehen lassen, da diese zu den erwarteten Ergebnissen zählen, aber Punkt 3 verwundert einen doch sehr. Wie kann es sein, dass trotz der in \textbf{Kapitel \ref{subsubsec:neon}} beschriebenen Vorteile der NEON-SIMD-Einheit gegen über der VFP-Einheit, beide Einheiten doch gleichwertig erscheinen? Es soll nochmals erwähnt werden, dass beide Implementationen mit einer Compileroption für die jeweilige Floating Point-Einheit optimiert wurden. Ein Blick in den entstandenen Assemblercode der beiden Implementierungen gibt die Antwort auf die gestellte Frage. Hier finden sich in beiden Fällen nahezu gleiche Codes, das heißt auch die NEON-SIMD-Einheit für nur die rein sklaren Operationen des VFP aus. Dieses erklärt einerseits, warum sich die Laufzeiten der beiden Implementationen nicht wesentlich voneinander unterscheiden und zeigt andererseits, dass es dem Compiler scheinbar nicht möglich ist effektiv für die NEON-SIMD-Einheit optimierten Code zu generieren.\\\\
Da die Extraktionsphase sich als am zeitintensivsten herausgestellt hat, soll diese jetzt näher analysiert werden.\\ 
Wie aus \textbf{Abbildung \ref{fig:1fset2}} zu entnehmen ist, fallt der größte Anteil der Laufzeit der Extraktionsphase mit knapp 60\% auf die Berechnung der FFT.
%
\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/1fset2.pdf}
	\caption{Detailliertere Laufzeitmessung der Extraktionsphase}
	\label{fig:1fset2}
\end{figure} 
%
Nachdem die FFT als größter Bottleneck identifiziert wurde, stellt sich die Frage welcher Teil der Berechnung die meiste Zeit einnimmt. Wie in \textbf{Kapitel \ref{subsubsec:fft}} beschrieben, besteht die FFT-Berechnung aus drei Teilen:

\begin{itemize}
\item Bitreverse
\item Butterfly
\item Nachverarbeitung
\end{itemize}  

Eine Analyse dieser drei Teilberechnungen ergibt, dass der größte Anteil an der Laufzeit der Butterfly-Berechnung zufällt, in Zahlen liegt dieser bei knapp 72\%.

\subsection{Libav als Optimierung der FFT}\label{subsec:optFFT}

Im vorherigen Kapitel haben sich folgende Ergebnisse gezeigt:

\begin{enumerate}
\item ARM+NEON ist die schnellste Kombination
\item Die Extraktionsphase nimmt den größten Anteil der Gesamtlaufzeit ein
\item Die FFT nimmt den größten Anteil an der Laufzeit der Extraktionsphase ein
\item Innerhalb der FFT nimmt die Butterfly-Berechnung den größten Anteil ein
\end{enumerate}

Daraus folgt, dass eine erste Optimierung in Richtung der FFT und der NEON-SIMD-Einheit erfolgen sollte.\\
Bibliotheken, die NEON optimierte FFT-Versionen bieten, sind im Internet reichlich vertreten. Für diese Arbeit wurde sich dafür entschieden die weitverbreiteste Bibliothek \textit{Libav} einzusetzen.\\
Libav ist eine opensource Bibliothek zur Audio- und Videoverarbeitung, die neben einer Vielzahl von Audio- und Videocodecs, Prozessierungsalgorithmen für diese und Tools zur Audio- und Videoverarbeitung auch wie schon erwähnt eine NEON optimierte FFT besitzt.
 
\subsubsection{Laufzeitmessung}
Da der Aufbau der FFT-Berechnung (siehe \textbf{Kapitel \ref{subsubsec:libavfft}}) der Libav-Bibliothek an anderer ist, als der der Referenzimplementierung, wäre ein direkter Laufzeitvergleich zwischen Libav-FFT und Referenz-FFT unfair. Hier für wurden die Messungen der drei Kombinationen aus \textbf{Abbildung \ref{fig:armtime}} für die Libav-FFT wiederholt (vgl. \textbf{Abbildung \ref{fig:libavtime}}).
%
\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/libavtime.pdf}
	\caption{Laufzeitmessung der Libav-FFT für ARM, ARM+VFP und ARM+NEON}
	\label{fig:libavtime}
\end{figure} 
%
Auch hierbei lässt sich erkennen, dass eine reine ARM-Implementation die langsamste Variante ist. Allerdings lässt sich ebenfalls erkennen, dass der Unterschied von der VFP-Implementierung und der NEON-Implementierung sehr deutlich ist, so wie es zu erwarten war. Dass dieser Unterschied hier so deutlich ist, liegt vor allem daran, dass die NEON-Version nicht wie bei der FFT des Referenzcodes mit der Compileroption für NEON-Code erstellt wurde, sondern wie in \textbf{Kapitel \ref{ph:neonasm}} beschrieben per Hand in NEON-Assembler geschrieben wurde.

\subsubsection{Aufbau der FFT}\label{subsubsec:libavfft}
Wie im vorherigen Kapitel schon erwähnt, unterscheiden sich der Aufbau von Libav-FFT und FFT des Referenzcodes stark, was unter anderem eine Komplexitätsreduktion der Butterfly-Berechnung und damit eine geringere Laufzeit mit sich bringt. In diesem Abschnitt wird nun dieser Unterschiedliche Aufbau näher erläutert.\\
Die FFT des Referenzcodes basiert auf den in \textbf{Kapitel \ref{subsubsec:fft}} beschriebenen Reduktionen einer 256-Punkt-FFT auf kleinere FFTs und gehört zur Familie der DIT-FFTs. Der Aufbau der Libav-FFT hingegen basiert auf der Reduktion auf Splitradix-FFTs, allerdings gehört auch diese FFT zur Familie der DIT-FFTs.\\
\textbf{Abbildung \ref{fig:libav-bf}} zeigt den Aufbau eines Splitradix-Butterflys der Libav-FFT.


\subsubsection{Einbindung}
\subsubsection{Abschließende Laufzeitmessung nach der FFT-Optimierung mit Libav}

\subsection{Optimierung der Amplitude of Spectrum}\label{subsec:optAOS}
\subsubsection{Laufzeitmessung}
\subsubsection{Codeanpassung}

\subsection{Optimierung von MFCC}

\subsection{Optimierung der Zero Crossing Rate}



 
