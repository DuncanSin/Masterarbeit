
\section{ARM-spezifische Implementierung und Optimierung des Referenz-Programm-Codes}\label{sec:optarm}
In diesem Abschnitt wird zunächst der Referenz-Programm-Code auf den ARM Cortex A8 portiert. Diese Portierung ist ohne Änderungen möglich und soll daher nicht weiter beschrieben werden.\\
Als nächstes wird eine Laufzeitmessung der gesamten Signalverarbeitung durchgeführt. Hierbei wird der Programmcode ohne beschleunigte Fließpunkt-Berechnungen, mit VFP-Unterstützung, sowie für die Verwendung von SIMD-Instruktionen kompliliert. Auf diese Weise kann der Vorteil der Fließpunkt-Hardware quantitativ bewertet werden. Im Anschluss daran wird der rechenintensivste Schritt, die Merkmalsextraktion, auf Basis der definierten Optimierungsstrategie schrittweise beschleunigt.



\subsection{Laufzeitmessung des portierten Referenz-Programm-Codes}\label{subsec:armtime}
\textbf{Abbildung \ref{fig:MCLAVN}} zeigt die zuvor beschriebene Laufzeitmessung.
%
\begin{figure}[htp]
	\centering
		\includegraphics[scale=0.5]{../Pictures/MCLAVN.pdf}
	\caption{Laufzeiten in ms des Musikklassifikators mit ohne und mit beschleunigter Fließpunkt-Berechnung}
	\label{fig:MCLAVN}
\end{figure} 
%
Aus der Abbildung lässt sich entnehmen, dass ARM+VFP und ARM+NEON die schnelleren Varianten sind. Diese erzielen bereits einen Speedup zwischen 2,1 (MCL3) und 3,1 (MCL4) für die Verwendung der VFP-Einheit und 2,6 (MCL3) und 3,3 (MCL4) für die Verwendung der NEON-SIMD-Einheit gegenüber der Variante ohne beschleunigte Fließpunktberechnung. Das größte Optimierungspotenzial bietet hierbei die ARM+NEON-Variante, da bei der ARM+VFP-Variante aufgrund der zugrundeliegenden Hardwareeinheit (vgl. \textbf{Kapitel \ref{ph:vfp}}) keine großen Verbesserungen der Laufzeit mehr zu erwarten sind. Die nahezu gleichen Ausführungszeiten sind damit begründet, dass der Compiler fast keine SIMD-Instruktionen beim ARM+NEON verwendet. Stattdessen werden die skalaren VFP-Instruktionen über die SIMD-Pipeline verarbeitet. Aus \cite{tineon} lässt sich des weiteren entnehmen, dass der Instruktionendurchsatz der NEON-SIMD-Einheit gegenüber der VFP-Einheit deutlich höher ist.\\
%
\begin{figure}[htp]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/mclneon.pdf}
	\caption{Laufzeitmessung in ms der einzelnen Schritte der Musikklassifikation für ARM+NEON}
	\label{fig:mclneon}
\end{figure} 
%
In \textbf{Abbildung \ref{fig:mclneon}} sind die Laufzeiten der einzelnen Schritte innerhalb der Musikklassifikation für die Variante mit beschleunigter Fließpunkt-Berechnung durch SIMD-Instruktionen zu sehen. Aus der Abbildung sind zwei Erkenntnisse zu ziehen. Erstens nimmt der Schritt der Merkmalsextraktion den größten Anteil an der Laufzeit der Musikklassifikation ein und zweitens benötigt die die Musikklassifikation mit MCL2 die längste Zeit. Daher wird eine Optimierung der Merkmalsextraktion durchgeführt und diese wird auf Basis der Musikklassifikationsmethode 2 geschehen. Messergebnisse der anderen Methoden befinden sich im Anhang.\\
%
\begin{figure}[htp]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/1fset2.pdf}
	\caption{Laufzeitanteile der Merksmalsextraktion für FSet2}
	\label{fig:fset2AVN}
\end{figure} 
%
\textbf{Abbildung \ref{fig:fset2AVN}} zeigt eine nähere Analyse des Extraktionsschritts. Hierbei stellt die Durchführung der FFT mit 58,6\% bei FSet2, sowie knapp 50\% bei FSet1 und FSet4, den zeitkritischsten Schritt der Extraktion dar. Zu 72\% sind die Laufzeiten durch die Butterfly-Operationen verursacht. Daher wird eine Optimierung der FFTs durch Verwendung von SIMD-Instruktionen für die Butterfly-Operationen verfolgt.

\subsection{Libav als Optimierung der FFT}\label{subsec:optFFT}

Zur Beschleunigung der FFT durch SIMD-Instruktionen wird auf die Libav-Bibliothek (kurz Libav) zurückgegriffen, welche für NEON-SIMD-Instruktionen optimiert ist und in vielen Software-Produkten Verwendung findet.\\
Libav ist eine opensource Bibliothek zur Audio- und Videoverarbeitung, die eine Vielzahl von Audio- und Videocodecs, Prozessierungsalgorithmen und Werkzeuge zur Audio- und Videoverarbeitung  besitzt.\\
Im Gegensatz zur FFT des Referenz-Programms basiert die Libav-FFT auf einer Split-Radix-Struktur. Die Beschleunigung der Libav-FFT resultiert somit aus einer Reduktion der Rechenkomplexität und aus der Verwendung von SIMD-Instruktionen. Um die Beschleunigung durch SIMD-Instruktionen bewerten zu können, muss also auch der Anteil der Laufzeitreduktion aufgrund der unterschiedlichen Rechenkomplexität bekannt sein. Diese beiden Anteile werden nachfolgend mit $S_{comp}$ für den Komplexitätsanteil und $S_{SIMD}$ für den SIMD-Anteil bezeichnet. Das Datenformat der Libav-FFT weicht von der Referenz-FFT ab und macht daher eine Konvertierung nach \cite{libavtemp} erforderlich. Diese Konvertierung wird allerdings in einem Schritt durchgeführt, der für die Referenz-FFT ebenfalls benötigt wird und hat daher keinen Einfluss auf die Berechnung von $S_{comp}$ und $S_{SIMD}$.


\subsubsection{Bestimmung von $S_{comp}$ und $S_{SIMD}$}

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/libavtime.pdf}
	\caption{Laufzeitmessungen von Refezenz-FFT und Libav-FFT für ARM, ARM+VFP und ARM+NEON für FSet2}
	\label{fig:libavtime}
\end{figure} 
%
\textbf{Abbildung \ref{fig:libavtime}} zeigt den Laufzeitvergleich von Referenz-FFT und Libav-FFT. Aus den Messungen ohne Fließpunkt-Beschleunigung lässt sich $S_{comp}$ mit einem Wert 1,33 von berechnen, da hier keine Beschleunigung durch Hardwareeinheiten besteht. Der $S_{SIMD}$ lässt sich aus \textbf{Formel \ref{eqn:speed}} berechnen.

\begin{equation}
\label{eqn:speed}
S_{all}=S_{comp} \cdot S_{SIMD}
\end{equation}

$S_{all}$ aus den beiden Messungen für ARM+NEON hat einen Wert von 20,1, somit kommt $S_{SIMD}$ auf einen Wert von 15,1. Insgesammt werden durch die Verwendung der Libav wird Fset2 um einen Faktor von 5,3 beschleunigt, FSet 1 und 4 sogar um 12,3, bzw. 14.

\subsection{Laufzeitmessung nach der FFT-Optimierung mit Libav}

Aufgrund der Laufzeit werden folgende Features hinsichtlich einer Optimierung untersucht:

\begin{itemize}
\item Octave Spectral Contrast (siehe \textbf{Kapitel \ref{subsec:armwopt}})
\item Magnitude of Sprectrum (\textbf{\ref{subsec:optAOS}})
\item MFCC (\textbf{\ref{subsec:optMFCC}})
\item Hamming Window (\textbf{\ref{subsec:optHAM}})
\item Zero Crossing Rate (siehe \textbf{Kapitel \ref{sec:vista}})
\end{itemize}

Die Optimierung von OSC erweist sich als sehr komplex. 76\% der Laufzeit dieses Merkmals fallen auf das verwendete Sortierverfahren. Eine Optimierung gängiger Sortierverfahren wie MergeSort oder QuickSort durch die Verwendung von SIMD-Instruktionen ist auf Grund der Sortierstrukturen und rekursiven Aufrufe nicht ohne weiteres möglich. Im schlimmster Fall wäre die Entwicklung eines eigenen Sortieralgorithmus auf Basis von SIMD-Instruktionen nötig, was den Rahmen dieser Arbeit aber übersteigen würden. Daher wird auf eine Optimierung der Berechnung des OSC-Merkmals verziechtet.
Auch das ZCR-Merkmal ist nicht ohne weiteres mit SIMD-Instruktionen möglich, da über 90\% der Laufzeit auf die Signum-Berechnung fallen, welche nur schwer oder garnicht auf SIMD-Instruktionen abbildbar ist. Eine Optimierung der Signum-Berechnung ohne SIMD-Instruktionen ließe sich durch geschicktes Anordnen der Vergleiche erreichen. Diese wäre jedoch aufgrund der Datenabhängigkeit von Musikstück zu Musikstück unterschiedlich.


\subsection{Optimierung der Magnitude of Spectrum}\label{subsec:optAOS}

\begin{figure}[h]
	\centering
		\includegraphics[scale=0.5]{../Pictures/mag.pdf}
	\caption{Laufzeitmessung von Magnitude of Spectrum für ARM, ARM+VFP und ARM+NEON für FSet2}
	\label{fig:mag}
\end{figure} 
%
\textbf{Abbildung \ref{fig:mag}} zeigt die Laufzeit von MAG bei den drei Fließpunkt-Berechnungsmethoden. Es lässt sich erkennen, dass durch die Verwendung der Fließpunkt-Hardware eine Beschleunigung vom Faktor 13,6 erreichen lässt. Ein Blick in den Assembler-Code zeigt aber, dass keine NEON-SIMD-Instruktionen verwendet wurden. Der Grund hierfür besteht darin, dass im Instruktionssatz der NEON-SIMD-Einheit keine Operationen zur Wurzelberechnung existieren und der Compiler diese daher nicht auf SIMD-Instruktionen abbilden kann.\\
Die einfachste Möglichkeit dieses zu lösen, besteht darin die Wurzelberechnung aus der Schleife zu entfernen und in einer gesonderten Schleife zu platzieren. Die parallelisierbare Division befindet sich aber nach der Wurzelberechnung. Die Lösung hierfür besteht darin, die Division auf mathematischen Weg in die Wurzel zu ziehen. \textbf{Listing \ref{code:aosc}} zeig den auf diese Weise geänderten Quellcode und \textbf{Listing \ref{code:aosasm}} den daraus resultierten Assemblercode. 

\begin{lstlisting}[caption=Codeanpassung der Magnitude of Spectrum, label=code:aosc]
	realv tmp, size2;

	size2 = (realv) size * size;
	for (int k = 0; k < size; k++) {
		tmp = fftX[k] * fftX[k] + fftY[k] * fftY[k];

		temp[k] = tmp / size2;

	}
	for (int k = 0; k < size; k++) {
		amplitude[k] = sqrt(temp[k]);
	}
\end{lstlisting}
Aus den beiden Listings lässt sich erkennen, dass sowohl die Zeile 5 aus \textbf{Listing \ref{code:aosc}} als auch die Division mit der NEON-SIMD-Einheit parallelisiert wurden, was eine kürzere Ausführungszeit bewirkt.

\begin{lstlisting}[caption=Resultierender Assemblercode, label=code:aosasm]
	add	r2, r7, r1
	add	r3, r6, r1
	vld1.32	{d16}, [r2]       ;laden aus fftX;
	add	r0, r0, #1
	vld1.32	{d17}, [r3]		  ;laden aus fftY;
	vmul.f32	d16, d16, d16 ;fftX[k] * fftX[k];
	cmp	r0, ip
	vmla.f32	d16, d17, d17 ;+ fftY[k] * fftY[k];
	add	r3, r4, r1
	vmul.f32	d16, d18, d16 ;Division dargestellt als Multiplikation;
	add	r1, r1, #8
	fstd	d16, [r3, #0]
	bcc	.L95
	cmp	r5, sl
	mov	r1, sl
\end{lstlisting}

Auf diese Weise lässt sich die Laufzeit von MAG gegenüber der Laufzeit von ARM+NEON aus \textbf{Abbildung \ref{fig:mag}} um den Faktor 2,1 beschleunigen, so dass insgesamt eine Beschleunigung von 27,9 gegenüber der Laufzeitmessung von ARM erreicht wird.\\
Die Gesamtlaufzeiten von FSet 1, 2 und 4 wurden damit im Vergleich zur complieroptimierten SIMD-Version um einen Faktor von knapp 1,2 beschleunigt.

\subsection{Optimierung von Hamming Window}\label{subsec:optHAM}

Da die Berechnung des Hamming Windows nur aus einer Multiplikation von zwei Single Precision Werten besteht, lässt sich diese auch mit SIMD-Instruktionen realisieren. Zu diesem Zweck wird diese Berechnung durch eine äquivalente Berechnung mit NEON-Intrinsics realisiert. \textbf{Listing \ref{code:hamc}} zeigt den Referenz-Code der Hamming Window-Berechnung und \textbf{Listing \ref{code:hamint}} die äquivalente Berechnung mit NEON-Intrinsics.


\begin{lstlisting}[caption=Referenzcode von Hamming Window, label=code:hamc]
	for (unsigned int i = 0; i < size; i++) {
		result[i] = (*signal)[i] * table[i];
	}
\end{lstlisting}

\begin{lstlisting}[caption=Hamming Window mit NEON-Intrinsics, label=code:hamint]
	for (unsigned int i = 0; i < size; i += 4) {
		s4 = vld1q_f32((float32_t*) &(*signal)[i]);
		t4 = vld1q_f32((float32_t*) &table[i]);
		r4 = vmulq_f32(s4, t4);
		vst1q_f32((float32_t*) &result[i], r4);
	}
\end{lstlisting}

In die Variablen \textit{s4} und \textit{t4} werden jeweils vier Werte vom Eingangssignal, bzw. den Hammingwerten geladen und danach parallel mit dem Intrinsic \textit{vmulg\_f32} Multipliziert. Abschließend wird das Ergebnis dieser Multiplikationen (\textit{r4}) in den Ausgangsvektor geschrieben.\\
Auf diese Weise kann die Berechnung des Hamming Windows im Vergleich zur Berechnung ohne beschleunigte Fließpunkt-Berechnung um den Faktor 2,6 beschleunigt werden. Insgesamt wird hierdurch die Berechnung des FSet2 zusätzlich um den Faktor 1,2 beschleunigt.

\subsection{Optimierung von MFCC}\label{subsec:optMFCC}
Zur Optimierung der MFCC-Extraktion werden die Laufzeiten der drei wesentlichen Extraktionsschritte (siehe \textbf{Abschnitt \ref{subsubsec:mfcc}}) gemessen. Hierbei lässt sich feststellen, dass der größte Anteil mit knapp 44\% auf die Anwendung der Filterbank fällt, während jeweils 29\% durch die Logerithmierung und die DCT verursacht sind. Daher wird im Folgenden eine Optimierung der Filterbank-Anwendung angestrebt.\\
\textbf{Listing \ref{code:mfccc}} zeigt den Referenzcode der Akkumulation innerhalb der MFCC-Berechnung.

\begin{lstlisting}[caption=Referenzcode der Akkumulation innerhalb der MFCC-Berechnung, label=code:mfccc]
for (unsigned int m = 1; m <= M; m++) {
   for (unsigned int k = f_edge_table_bd[m - 1];k <= f_edge_table_bd[m + 1]; k++) {
		log_M[m - 1] += (*signal)[k] * wk[m - 1][k];

   }
}
\end{lstlisting}

Aus diesem Code-Ausschnitt lässt sich entnehmen, dass die in den zwei Schleifen enthaltene Akkumulation nicht für jeden Durchlauf gleich oft ausgeführt wird. Dies führt dazu, dass die Anzahl der Schleifendurchläufe durch einen gemeinsamen Vielfachen beschrieben werden kann. Maximal können mit SIMD-Instruktionen vier Berechnungen quasi gleichzeitig ausgeführt werden (vgl. \textbf{Abschnitt \ref{ph:neon}}), daher muss als erstes die Anzahl der Schleifendurchläufe berechnet werden, in denen eine parallele Verarbeitung von vier Berechnungen möglich ist. Außerdem wird hierbei berechnet, wie viele Operationen danach noch ausgeführt werden müssen (maximal 3). Als nächstes wird geprüft, ob von den verbleibenden Operationen noch zwei parallel verarbeitet können. Am Schluss bleibt höchstens noch eine Operation übrig, die einzeln berechnet werden muss. Nachfolgend müssen die Einzelergebnisse der jeweiligen Parallelisierungsstufen zu einem Endergebnis aufsummiert werden.\\
\textbf{Listing \ref{code:mfccint}} zeigt die gewählte Lösung und ersetzt die innere Schleife aus \textbf{Listing \ref{code:mfccc}}. In der Variable \textit{mod} wird die Anzahl der nicht durch vier parallele Rechnungen berechenbaren Durchläufe gespeichert, danach werden in den Zeilen 8-15 so viele parallelen vierfach Berechnung durchgeführt wie möglich. Sollte \textit{mod} größer als 1 sein, also noch zwei parallele Berechnungen möglich sein, werden diese in den Zeilen 17-25 durchgeführt. Wenn danach immer noch eine Berechnung fehlen sollte, wird diese in den Zeilen 27-29 durchgeführt. Abschließend werden in Zeile 31 die Einzelergebnisse aufsummiert. 
\newpage
\begin{lstlisting}[caption=Akkumulation innerhalb der MFCC-Berechnung mit NEON-Intrinsics, label=code:mfccint]
	mod = (f_edge_table_bd[m + 1] - f_edge_table_bd[m - 1]+1) % 4;

	memset(&temp[0], 0., temp.size() * sizeof(realv));

	fedtbd = f_edge_table_bd[m + 1];
	fedtbd2 = fedtbd-mod+1;

	r4 = vld1q_f32((float32_t*) &temp[0]);
	for (unsigned int k = f_edge_table_bd[m - 1]; k < (fedtbd - mod); k +=4) {
		s4 = vld1q_f32((float32_t*) &(*signal)[k]);
		w4 = vld1q_f32((float32_t*) &(wk.data()[m - 1])[k]);

		r4 = vmlaq_f32(r4, s4, w4);
	}
	vst1q_f32((float32_t*) &temp[0], r4);

	if (mod > 1) {
		s2 = vld1_f32((float32_t*) &(*signal)[fedtbd2]);
		w2 = vld1_f32((float32_t*) &(wk.data()[m - 1])[fedtbd2]);
		r2 = vld1_f32((float32_t*) &temp[0]);
		t2 = vmla_f32(r2, s2, w2);
		vst1_f32((float32_t*) &temp[0], t2);
		mod -= 2;
		fedtbd2 += 2;
	}

	if (mod == 1) {
		log_M[m - 1] = (*signal)[fedtbd] * wk[m - 1][fedtbd];
	}
	
	log_M[m - 1] += temp[0] + temp[1] + temp[2] + temp[3]+1;
\end{lstlisting}

Mit dieser Lösung kann die MFCC-Berechnung um den Faktor 1,9 für FSet 1 und 2 im Vergleich zur Realisierung ohne beschleunigte Fließpunkt-Berechnung beschleunigt werden. Insgesamt werden FSet1 und FSet2 nochmals um den Faktor 1,2 beschleunigt.




 
