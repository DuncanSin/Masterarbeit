
\section{DSP-spezifische Optimierung der implementierten Merkmalsextraktion}\label{sec:optdsp}
Für die Merkmalsextraktion auf dem C674x DSP wurde eine C-Version der C++-Referenz-Klasse geschrieben. da der Compiler C++ nur in geringem Umfang unterstützt. Außerdem wurde für die Einbindung der Merkmalsextraktion in den ARM-Code C6Runlib gewählt, da für C6Runapp keine Komunikationsprotokolle definiert sind.\\
Die Laufzeiten zur Extraaktion der Merkmale und zur Durchführung erforderlicher Algorithmen sin in \textbf{Abbildung \ref{fig:startdsp}}zu sehen.\\
%
\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/startdsp.pdf}
	\caption{Laufzeitanteile der einzelnen Features}
	\label{fig:startdsp}
\end{figure} 
%
Wie der Abbildung entnommen werden kann, fällt der größte Anteil der Ausführungszeit mit über 60\% der MAG-Berechnung zu.\\

\subsection{Optimierung der Rechenfunktionen mit MATHLIB}\label{sec:mathlib}
Eine genaue Analyse der Laufzeit der MAG-Berechnung zeigt, dass 98\% der Verarbeitungszeit auf die Berechnung der Division und Wurzelberechnung fallen, die mehrfach ausgeführt werden. Zur Beschleunigung dieser Operationen eignen sich die MATHLIB-Funktionen für vektorielle Eingabewerte.\\
\textbf{Listing \ref{code:aoscc}} zeigt den Referenz-Code der MAG-Berechnung und \textbf{Listing \ref{code:aoscm}} durch MATHLIB optimierten Code.

\begin{lstlisting}[caption=Referenzcode von Magnitude of Spectrum, label=code:aoscc]
	A[k] = sqrt(X[k] * X[k] + Y[k] * Y[k]) / G;
\end{lstlisting}

\begin{lstlisting}[caption=Magnitude of Spectrum mit MATHLIB, label=code:aoscm]
	for (k = 0; k < G; ++k) {
		tmp1 = X[k] * X[k];
		tmp2 = Y[k] * Y[k];
		A[k] = (tmp1 + tmp2); //(X[k] * X[k] + Y[k] * Y[k]);
	}
	
	sqrtsp_v(A, A, G);

	divsp_v(A, pG, A, G);
\end{lstlisting}

Hierbei ist zu erwähnen, dass die Addition innerhalb der Wurzelberechnung wird zusätzlich für eine bessere Ausführung durch SPLOOP aufgetrennt wird.\\
Mit dieser Optimierung wird für FSet 1 und 4 eine Beschleunigung um den Faktor 45,5 und bei FSet2 um 45,2 erreicht.\\
Die MATHLIB wird außerdem für die Optimierung folgender Algorithmen eingesetzt:

\begin{itemize}
\item MFCC
\item Low Energy
\item Normalized Audio Spectrum Envelope
\item Octave Spectral Contrast
\item Root Mean Square
\item Spectral Centroid
\item Spectral Crest Factor
\item Spectral Flux
\item Sub-band Energy Ratio
\end{itemize}

Die Beschleunigungen dieser Merkmale ist in \textbf{Tabelle \ref{tab:math}} angegeben.

\begin{table*}[ht]
	\centering
		\begin{tabular}{c|c|c|c|c|c|c|c|c|c}
		
		& MFCC & LE & NASE & OSC & RMS & SC & SCF & SF & SBER\\
		\hline
		Faktor & 3 & 2,4 & 2,2 & 2,2 & 1,3 & 1,4 & 2,2 & 1,05 & 1,8\\
					
		\end{tabular}
	\caption{Tabelle der verwendeten Ausdrücke und Variablen}
	\label{tab:math}
\end{table*}

Insgesamt werden durch die Einbindung von MATHLIB die FSets 1, 2, 3 und 4 um die Faktoren 4.6, 4.1, 1.1 und 4.7 beschleunigt.

\begin{figure}[h]
	\centering
		\includegraphics[width=1\textwidth]{../Pictures/dsp2.pdf}
	\caption{Laufzeitmessung nach der Optimierung durch MATHLIB}
	\label{fig:dsp2}
\end{figure} 
%
\textbf{Abbildung \ref{fig:dsp2}} veranschaulicht die Laufzeit-Verbesserungen der Merkmale durch die MATHLIB.\\
Des weiteren fällt auf, dass die FFT-Berechnung nun die längste Laufzeit aufweist.

\subsection{Optimierung der FFT mit DSPLIB}\label{sec:dsplib}
Die Beschleunigung der FFT wird mit Hilfe der DSPLIB-Implementierung realisiert. Hierbei wird der Programm-Code der MAG aufgrund des geänderten Datenformats angepasst.\\
Dieses beschleunigt die FFT-Berechnung für FSet 1, 2 und 4 je um den Faktor 3,8. Insgesamt werden die FSets 1, 2 und 4 zusätzlich um die Faktoren 2, 1,6 und 2,2 beschleunigt.\\
Nach der Optimierung mit der DSPLIB sind die Berechnungen der Merkmale OSC und ZCR langsamer als die Berechnung der FFT.

\subsection{Optimierung des Sortierverfahrens der Octave Spectral Contrast-Berechnung}\label{subsec:optosc}
Eine genauere Analyse der Berechnung des OSC-Merkmals zeigt, dass 54\% der Rechenzeit dieses Merkmals auf die Sortierung fallen. Also wird eine Optimierung des Sortierverfahrens angestrebt.\\
Bei dem im Referenz-Code verwendeten Sortierverfahren handelt es sich um einen Algorithmus, der auf dem Quick Sort-Verfahren basiert. Nach Angaben von Texas Instruments\cite{sort} werden Merge Sort-Algorithmen auf dem C674x DSP laufezeiteffektiver ausgeführt, als Quick Sort-Algorithmen, obwohl beide in die  Komplexitätsklasse $O(n \, log(n))$ fallen. In dem selben Dokument wird ebenfalls ein optimierter Algorithmus auf dem Merge Sort-Verfahren basierend präsentiert. Dieser für Integer konzipierte Algorithmus wird für die Verwendung mit Fließpunktzahlen und die Sortierung in absteigender Reihenfolge umgeschrieben und in die OSC-Berechnung integriert.\\
Die Ersetzung des Quick Sort-Verfahrens durch das in \cite{sort} vorgeschlagene Merge Sort-Verfahren beschleunigt die Berechnung des OSC-Merkmals um den Faktor 1,1 . Insgesamt wird hierdurch die Berechnung von FSet2 um den Faktor 1,05 beschleunigt.

\subsection{Optimierung für SPLOOP}\label{sec:compiler} 
Ein Blick in den Assemblercode der Zero Crossing Rate zeigt, dass für die Schleife keine SPLOOP-Optimierung vom Compiler durchgeführt wurde. Dieses lässt sich aber durch eine einfache Codeumstellung lösen. \textbf{Listing \ref{code:zcrc}} zeigt den Referenzcode der Zero Crossing Rate und \textbf{Listing \ref{code:zcrs}} den umgestellen Code.

\begin{lstlisting}[caption=Referenzcode der Schleife der Zero Crossing Rate, label=code:zcrc]
	for (n = 0; n < zinfo.N - 1; ++n) {
		zero_crossings += ABS(SGN(signal[n])-SGN(signal[n+1]));
	}
\end{lstlisting}

\begin{lstlisting}[caption=Für SPLOOP umgestellter Code der Schleife der Zero Crossing Rate, label=code:zcrs]
	for (n = 0; n < zinfo.N - 1; ++n) {
		tsgn1 = SGN(signal[n]);

		tsgn2 = SGN(signal[n+1]);

		tsub = tsgn1 - tsgn2;

		tabs = ABS(tsub);

		zero_crossings += tabs;
	}
\end{lstlisting}

Die Code-Umstellung beschleunigt die ZCR-Berechnung um einen Faktor von 7,7, so dass die Berechnung von FSet3 um den Faktor 3,9 beschleunigt wird.